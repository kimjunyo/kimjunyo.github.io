---
layout: single
title: "Collection"
---

## ChatGPT 문제집

#### **1. 객관식 (10문제)**
1. 컬렉션 프레임워크에서 **List** 계열의 특징으로 올바른 것은?  
   ① 순서를 유지하지 않는다.  
   ② 중복을 허용하지 않는다.  
   ③ 크기가 고정되어 있다.  
   ④ 중복을 허용하며 순서를 유지한다.

2. **ArrayList**의 주요 특징으로 적절한 것은?  
   ① 삽입과 삭제가 빠르다.  
   ② 인덱스를 통한 접근이 빠르다.  
   ③ LinkedList보다 조회 속도가 느리다.  
   ④ 크기가 고정되어 있다.

3. **Set** 계열 컬렉션의 특징이 아닌 것은?  
   ① 중복을 허용하지 않는다.  
   ② 저장된 데이터의 순서를 유지한다.  
   ③ null 값을 하나만 저장할 수 있다.  
   ④ equals() 메서드를 반드시 재정의해야 한다.

4. **HashMap**의 키(key)에 대한 설명으로 틀린 것은?  
   ① 키는 중복될 수 없다.  
   ② 하나의 null 키를 허용한다.  
   ③ 값(value)은 중복될 수 있다.  
   ④ 키는 여러 개의 null 값을 가질 수 있다.

5. **Comparator** 인터페이스를 사용하는 목적은?  
   ① 객체의 기본 정렬 기준을 정의하기 위해  
   ② 정렬 기준을 실행 중에 동적으로 변경하기 위해  
   ③ 객체를 리스트에서 삭제하기 위해  
   ④ 중복된 데이터를 허용하기 위해

6. **TreeSet**의 특징이 아닌 것은?  
   ① 데이터를 정렬된 상태로 유지한다.  
   ② 기본적으로 오름차순 정렬을 수행한다.  
   ③ null 값을 저장할 수 있다.  
   ④ Comparator를 사용해 정렬 기준을 지정할 수 있다.

7. **싱글턴 패턴을 적용할 때 반드시 해야 하는 것**은?  
   ① 생성자를 public으로 설정한다.  
   ② 여러 개의 객체 생성을 허용한다.  
   ③ private static 인스턴스를 하나만 생성한다.  
   ④ 객체 생성을 제한하지 않는다.

8. **Comparable 인터페이스**와 **Comparator 인터페이스**의 차이로 적절한 것은?  
   ① Comparable은 특정 클래스 내부에서 정렬 기준을 정의하고, Comparator는 외부에서 정렬 기준을 정의한다.  
   ② Comparator는 클래스 내부에서만 사용 가능하다.  
   ③ Comparable은 동적으로 정렬 기준을 변경할 수 있다.  
   ④ Comparable은 여러 개의 정렬 기준을 가질 수 있다.

9. **Vector**와 **ArrayList**의 차이점으로 맞는 것은?  
   ① Vector는 동기화(synchronized) 지원을 하지 않는다.  
   ② ArrayList는 동기화를 지원한다.  
   ③ Vector는 동기화를 지원하기 때문에 멀티스레드 환경에서 더 적합하다.  
   ④ ArrayList는 삽입 및 삭제가 빠르다.

10. **람다식 사용이 가능한 경우**는?  
    ① 모든 인터페이스에 대해 사용 가능하다.  
    ② @FunctionalInterface 어노테이션이 적용된 인터페이스에서만 사용 가능하다.  
    ③ 추상 메서드가 여러 개인 인터페이스에서도 사용할 수 있다.  
    ④ default 메서드만 포함된 인터페이스에서도 사용할 수 있다.

---

#### **2. 단답형 (10문제)**
11. **List**, **Set**, **Map** 중에서 **순서를 유지하고 중복을 허용하는 컬렉션**은?
12. **Set 컬렉션에서 중복을 방지하기 위해 반드시 재정의해야 하는 메서드**는?
13. **TreeMap과 TreeSet이 데이터를 정렬하는 데 사용하는 알고리즘**은?
14. **Comparator 인터페이스에서 반드시 구현해야 하는 메서드의 이름**은?
15. **Comparable 인터페이스에서 반드시 구현해야 하는 메서드의 이름**은?
16. **HashSet이 내부적으로 데이터를 저장하는 데 사용하는 자료구조**는?
17. **LinkedList의 장점은 무엇인가?** (한 단어 또는 짧은 문장)
18. **싱글턴 패턴을 적용하기 위해 생성자의 접근 제한자는 무엇이어야 하는가?**
19. **ArrayList에서 중간에 요소를 삽입하거나 삭제할 때 성능이 저하되는 이유는 무엇인가?**
20. **Comparator와 Comparable 인터페이스가 모두 구현된 경우, 정렬 시 우선 적용되는 것은?**

---

#### **3. 서술형 (10문제)**
21. **ArrayList와 LinkedList의 차이를 비교하여 설명하세요.**
22. **HashSet과 TreeSet의 차이점을 설명하세요.**
23. **HashMap과 TreeMap의 차이점을 설명하세요.**
24. **Comparator와 Comparable 인터페이스의 차이를 설명하고, 언제 각각을 사용하는 것이 좋은지 설명하세요.**
25. **람다식을 사용할 수 있는 조건과 그 장점에 대해 설명하세요.**
26. **내부 클래스와 익명 클래스의 차이점을 설명하세요.**
27. **싱글턴 패턴이 필요한 이유와 구현 방법을 설명하세요.**
28. **Collections.sort()를 사용할 때, 특정 객체 리스트를 정렬하려면 어떤 조건이 필요한지 설명하세요.**
29. **제네릭을 사용하는 이유와 장점에 대해 설명하세요.**
30. **FunctionalInterface의 특징과 주요 예제(예: Comparator) 를 설명하세요.**

